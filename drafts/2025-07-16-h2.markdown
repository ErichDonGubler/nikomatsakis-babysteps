---
title: "Idea-oriented programming"
date: 2025-07-16T09:10:26-04:00
draft: true
---

You've probably heard people telling you that, as the usage of AI coding assistants grows, English will be the programming language of the future. I don't believe it. At the same time, I *do* believe that programming is undergoing a huge shift right now. I don't claim to be able to predict the *details* of where we are going to end up, but I think the outlines are coming into focus: programming is going to be a lot more about *ideas* and a lot less about *details*. I'm pretty excited about this, I feel like this has been the goal of programming languages since forever, and I think it's a fundamentally *empowering* concept. I also think it has interesting implications for what is important in a programming language.

## Example: my family tree application

Over the last few months, I've been working extensively with AI-based CLI tools like [Claude Code][] and [Q CLI][][^disclaimer], trying to get a feeling for how they work. In this post I'm going to focus on my experiences with one of them, a web-based family tree app.

Why do I want a family tree app? Well, my family rather eerily resembles the one from My Big Fat Greek Family, which means that I frequently meet people and want to know exactly how (or if) we are related. My dad long ago compiled a lot of family tree data but it was in an obscure format and not useful when you are meeting someone on the street, so I wanted to have it exposed as a mobile app. Some time back, I had laid the groundwork, writing Rust code to process the parse my dad's format and then a rudimentary frontend (in Ember) to display it. It could even compute the relationship between people. But the interface was, shall we say, primitive. It used no CSS and just use HTML lists to show relationships between people. The only way to search was to use the browser's built-in search command. It was an interface only a coder could love. And that was as far as I was going to get on my own without investing a *ton* more time to learn stuff about HTML/CSS.

[Claude Code]: https://www.anthropic.com/claude-code

[Q CLI]: https://docs.aws.amazon.com/amazonq/latest/qdeveloper-ug/command-line.html

[^disclaimer]: Disclaimer: Q CLI is an Amazon product, which is where I work. I use it when doing things at work both because it works well and because I want to dogfood; I generally use Claude Code for the personal projects I do on my own time. It also works well. I tried more IDE-based tools like Copilot, Cursor, and WindSurf, but I've found that I prefer the CLI-based tools overall, they are just so flexible and adaptable, and they lend themselves very well to the "partnership-oriented" style that I've come to prefer. That said, I do like Cline, and I use that sometimes. *Oh*, and fun fact I recently discovered: Q CLI is implement in Rust and [open source](https://github.com/aws/amazon-q-developer-cli)! I've spent a little time reading through the source. I've been debating if there are interesting experiments to run that would require modifying the tool itself? Maybe, though you can do an *awful lot* through MCP.

## AI tools can be *crazy* empowering

It is hard to convey how fundamentally **empowering** AI-based tools can be. As I said, I was completely stuck on this project for months -- but using Claude Code changed everything. Over the course of a few weeks, working an hour or two per day[^5am], I was able to build out the full application[^forme]. You can see a [demo] here using some data I found for Spock's family tree -- you can see it includes a visual layout, the ability to collapse and grow parts of the tree, search, and the ability to compute how you are related to others.[^coach] It even operates as a Progressive Web App, so it can be added to people's home screen and used offline (something I only vaguely knew was possible, but Claude suggested it and implemented the bits of random metadata quite easily).

[^5am]: Most days, I like to wake up at 5am to write code on some personal project or other for an hour.

[^coach]: I was in Greece for vacation over the last few weeks, and we met someone on the beach who shared our last name -- using the tree I discovered we are fourth cousins.

[^forme]: To be clear, I don't really expect this family tree app to be used by anybody but me, and I'm sure there are more full-featured competitors, but it was fun to build. And I like the idea of all the data being owned by me, not uploaded into some service.

## But out of the box, AI tools can be *disempowering*

When I first started using AI tools, I was using them all wrong. It's like I expected to outsource my thinking to them: I'd briefly describe what I wanted and the tool would run off and do crazy things across my codebase. Sometimes surprisingly successful, but sometimes spectacularly silly. And to be fair, I think the tools are setup to encourage this mentality. They seem to be geared to take a minimal prompt and immediately produce code.

This setup makes for a great demo, but it doesn't scale to maintaining a real codebase. Somewhat ironically, in their zeal to take complexity off of your plate, I think that the tools can easily become *disempowering* and frustrating. You have to spend as much or more energy babysitting them as you would doing the design in the first place, and there's no question that writing code is more fun than that.

## *Collaboration* is the key

What changed everything for me was shifting from thinking about Claude as an "assistant" or "code-authoring tool" to "collaborative partner". It started simple. Instead of saying "do X", I would say "give me 3 options for how to do X". Then I might say "Hmm, I like this about option 1, but I like that about option 3, what do you think?" And I would listen to the answer. Together, we would find something I liked very much.

Over time I've been tweaking my opening prompt and, inspired by some conversations with Yehuda Katz, leaning more into an approach I am calling **collaborative prompting**. This involves asking Claude (or whichever model you are working with) to talk about its feelings and sharing more of yourself in the process. Maybe that sounds a little cray cray, but it makes the whole process feel more organic and more enjoyable, and it brings out a side of Claude that is a lot more thoughtful.

This is all very much an experiment in progress. I expect to post more about it in the future, but if you want to dig deeper, check out my [socratic-shell][cp] repository, or you might enjoy Yehuda Katz's great blog post, ["You're Summoning the Wrong Claude"](https://wycats.substack.com/p/youre-summoning-the-wrong-claude). For starters, you could try setting up my [user prompt](https://socratic-shell.github.io/socratic-shell/prompts/user/index.html) as your context and see how it goes. Remember to greet Claude with "Hi again, Claude" when you start! I *think* that helps.

[cp]: https://socratic-shell.github.io/socratic-shell

## Where I see programming going





Suddenly, many of the things I had heard about prompt engineering were making more sense. For example, the statement that AI tools can "embody" different personas and that you want to get them in the right "mood". 

Of course, the question is how to "persist" that att

[^flashcard]: Here's a recent example. I was using claude.ai that "I am thinking of finally making the flashcard app of my dreams"[^dreams] and it responded with "Great! Here's an app built in react". I mean come on. 

[^dreams]: I basically hate all language learning apps. None of them work the way I want. I've tried to just get over it and use one of the standard offerings but I just can't take it.


For me, I I've found there's a kind of "mentality shift" that 



I mean, come on!

## AI tools can do awfully silly things

## Idea-oriented, T-shaped programming

So, 
## Programming is not 

I am more convinced than ever that the nature of programming is going to change very rapidly. 

AI-based programming is going to change how we work completely. 

I do not for a second believe programming is going away, but I also feel that AI is changing 

In my last blog post on AI, I wrote that "AI reminds me a lot of the web around the year 2000. It's clearly overhyped. [..] And it's also clearly going to change everything." Over the last few months, in my spare time, I've been working on a side project for visualizing my family tree.[^greece] It's got a Rust backend and a JavaScript frontend built on the Ember framework. I think 

[^greece]: My family resembles the one in my Big Fat Greek Wedding. I want a way to keep everybody straight!

I've been experimenting with AI-based agents over the past few months. A